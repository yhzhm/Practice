// Created by Hz Yang on 2019.01
#include <bits/stdc++.h>
using namespace std;
const int INF = 1000000;
char g[10][10];
int dx[] = {0, -1, 0, 1, 0}, dy[] = {0, 0, 1, 0, -1};
void turn(int x, int y) //将x，y位置的灯摁一下
{
	for (int i = 0; i < 5; ++i) {//遍历5个方向（5个位置）
		int a = x + dx[i], b = y + dy[i];
		if (a >= 0 && a < 5 && b >= 0 && b < 5) {
			g[a][b] = '0' + ('1' - g[a][b]); //等价于:g[a][b] ^= 1;48->49 49->48
		}
	}
}
int work()
{
	int ans = INF;
	for (int k = 0; k < 1 << 5; ++k) { //枚举第一行的所有可能的摁法
		int res = 0;//记录操作次数
		char backup[10][10];//操作之前备份状态
		memcpy(backup, g, sizeof g);
		for (int j = 0; j < 5; j++) {//对第一行就可能的摁法进行操作，改变状态
			if (k >> j & 1) {
				res++;
				turn(0, j);//turn 0行j列位置
			}
		}

		for (int i = 0; i < 4; ++i)//在第一行已经操作完毕的情况下，依次检查前4行，如果状态为0，在下一行进行状态的改变的操作
			for (int j = 0; j < 5; ++j) {
				if (g[i][j] == '0') {
					res++;
					// if (res > 6) break;
					turn(i + 1, j);
				}
			}
		bool is_successful = true;
		for (int j = 0; j < 5; ++j) {//检查最后一行的状态，判断是否全为1
			if (g[4][j] == '0') {
				is_successful = false;
				break;
			}
		}
		if (is_successful) ans = min(ans, res);
		memcpy(g, backup, sizeof g);//从backup还原g数组
	}
	if (ans > 6) ans = -1;
	return ans;
}
int main()
{
	int T;
	cin >> T;
	while (T--) {
		for (int i = 0; i < 5; ++i) cin >> g[i];
		cout << work() << endl;
	}
	return 0;
}

/*
两个性质：
1.每个位置至多只会被点一次。
2.若固定了第一行（不能再改变第一行），则满足题意的点击方案至多只有1种
第i行某一位置为0的话，只能通过点击第i+1行该位置上的数字才能使第i行这一位置变成0.
宽搜也可以做，宽搜第一次搜到的一定是最短的路径，
从全1状态开始搜，把所有6步以内的状态搜出来，做一个hash
求出每种状态的步数，然后查表就能得到答案，但复杂度偏高，
最坏情况应该是2^25==33554432,3千多万的复杂度
递推的做法：
锁定第一行，第一行不能摁，那要把第一行的第二列按成1，就要按第二行第二列
第一行锁定后，第二行需要摁的位置就确定了
第二行确定后，第三行就被第二行确定了。

枚举第一行的摁法，有2^5=32种摁法
完成第一行的一种点击方案后，第一行被确定（固定 ），根据第一行的状态，递推接下来的第二行，再根据第二行的状态，推第三行
一直检查到倒数第二行，根据倒数第二行的状态，推最后一行
最后检查最后一行的状态，是否全1
？为什么只检查最后一行的状态就可以了？
复杂度：32*20*5*500=1600000 160万
32：第一行可能的摁法
20：递推的复杂度，大概20步
5：每步的操作步数
500：输入的数据组的数量
 */