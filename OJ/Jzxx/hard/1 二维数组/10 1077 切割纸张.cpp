/*1077: 【基础】切割纸张
时间限制 : 1 Sec内存限制 : 16 Mb提交 : 1130解决 : 496
题目描述
把一张矩形的纸按平行于边的方向剪开，会得到很多矩形小纸片。如下图所示，最外围的矩形表示纸张，中间的线条表示切口。以下图中的切割方法，竖直方向上被切为5部分，水平方向上被切为3部分。如果我们记竖直方向上每部分的宽度为ai，竖直方向上每部分的高度为bi的话，这个切割方案就可以唯一确定了。

你的任务是，给定一个切割方案，请编写程序计算一下：在此切割方案之下，最终得到的矩形小纸片有多少种（同样大小、形状的记为一种）。
 
输入
第一行为两个整数 m（2 <= m <= 100 ）、 n（2 <= n <= 100 ），分别表示竖直方向和水平方向切割几部分。
第二行为m个整数，分别表示竖直方向上每个部分的宽度ai（1 <= i <= m），每个整数都不小于1，不大于50。
第三行为n个整数，分别表示水平方向上每个部分的高度bi（1 <= i <= n)，不大于50。
 
输出
一个整数，表示得到的小纸片的种数。
 
样例输入 [复制]
3 3
1 2 3
1 3 4
样例输出 [复制]
8
提示[+]
*** 提示已隐藏，点击上方 [+] 可显示 ***
来源
2008年北京市小学生网络练习赛二（5）*/

//
// Created by Hz Yang on 2017/6/20.
//
#include<iostream>

using namespace std;

int main() {
    int m, n, x, y, a[105], b[105], c[105][105] = {0}, cnt = 0;
    cin >> m >> n;
    for (int i = 0; i < m; ++i) {
        cin >> a[i];
    }
    for (int j = 0; j < n; ++j) {
        cin >> b[j];
    }
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            x = a[i];
            y = b[j];
            if (x > y) swap(x, y);
            if (!c[x][y]) cnt++;
            c[x][y] = 1;
        }
    }
    cout << cnt;
    return 0;
}
