/*题目描述
小明把 n (n 为偶数)张牌按编号顺序 1, 2, 3, ..., n 排成一堆，然后开始洗牌。一次洗牌的过程如下:
1. 对于一堆牌编号为 a1, a2, ..., an，首先将牌分成均匀的两堆:
a1, a2, ..., am和am+1, am+2, ..., an (其中m=n/2)
2. 然后按顺序交叉插入:
a1,am+1,a2,am+2,...,am,an
洗牌过程总共重复了 k 次，请你编程帮助小明模拟洗牌的过程。
例如 n = 6，初始时牌堆中牌的编号为 1, 2, 3, 4, 5, 6。
首次洗牌时，会将牌分成 1, 2, 3 和 4, 5, 6 两堆，交叉插入后的结果为 1, 4, 2, 5, 3, 6。
再次洗牌，会将牌分成 1, 4, 2 和 5, 3, 6 两堆。交叉插入后得到 1, 5, 4, 3, 2, 6。
 
输入
正整数 n (牌的数量), k (洗牌的次数), i (牌的位置)。1 ≤ n, k ≤ 1,000，1 ≤ i ≤ n， 保证 n 是偶数。
 
输出
n 张牌洗牌 k 次后，牌堆中第 i 张牌的编号。
 
样例输入
样例1: [复制]
6 2 5
样例2: [复制]
400 300 200
样例输出
样例1: [复制]
2
样例2: [复制]
368*/

//
// Created by Hz Yang on 2017/5/3.
//
#include <iostream>

using namespace std;

int main() {
    int n, k, x, a[1010], b[1010];
    cin >> n >> k >> x;
    for (int i = 1; i <= n; ++i) {
        a[i] = i;
    }
    int m = n / 2;
    for (int i = 1; i <= k; ++i) {
        for (int j = 1; j <= m; ++j) {
            b[j * 2 - 1] = a[j];
            b[j * 2] = a[m + j];
        }
        for (int j = 1; j <= n; ++j) {
            a[j] = b[j];
        }
    }
    cout << a[x] << endl;
    return 0;
}