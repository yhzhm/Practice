/*1543: 【基础】印度国王的棋盘
时间限制 : 1 Sec内存限制 : 64 Mb提交 : 525解决 : 284
题目描述
这是一个有名的古代故事。有一个数学家发明了一种棋盘献给了印度国王，数学家看国王非常欢喜，就向国王提出了奖赏的要求：在棋盘的第一格放一粒米，第二格放二粒米，第三格放四粒米，第四格放八粒米，．．．．．也就是说每一格都放进了比前一格多一倍的米。国王认为这简直不值一提，就毫不犹豫的答应了。谁知结果却让国王大吃一惊，当放到第64格时，就已经一共用了18446744073709551615粒米。这在当时要几百年才能种出来。 现假定该棋盘共有200格，请你编程计算从第N格至第M 格共有多少粒米，并以三位一撇的形式输出。
 
输入
键盘输入整数N，M（1≤N，M≤200不用判错）。
 
输出
精确输出从第N格至第M 格共有多少粒米，并以三位一撇的形式输出。
 
样例输入 [复制]
20 37
样例输出 [复制]
137,438,429,184
提示[+]
*** 提示已隐藏，点击上方 [+] 可显示 ***
来源
2001江苏省青少年信息学奥林匹克小学组竞赛复赛*/

//
// Created by Hz Yang on 2017/6/12.
//
#include <cstdio>
#include <iostream>

using namespace std;
int n, m, a[10000], b[10000], lena, lenb, i, j;

int main() {
    cin >> n >> m;
    a[1] = 1;
    lena = 1;
    b[1] = 0;
    lenb = 1;
    if (n == 1) b[1] = 1;
    for (i = 2; i <= m; ++i) {
        for (j = 1; j <= lena; ++j) {
            a[j] = a[j] * 2;
            if (i >= n) {
                b[j] += a[j];
            }
        }
        for (j = 1; j <= lena; ++j) {
            a[j + 1] += a[j] / 10;
            a[j] = a[j] % 10;
        }
        while (a[lena + 1] > 0) {
            lena++;
            a[lena + 1] += a[lena] / 10;
            a[lena] %= 10;
        }
        for (j = 1; j <= lenb; ++j) {
            b[j + 1] += b[j] / 10;
            b[j] %= 10;
        }
        while (b[lenb + 1] > 0) {
            lenb++;
            b[lenb + 1] += b[lenb] / 10;
            b[lenb] %= 10;
        }
    }
    for (i = lenb; i >= 1; --i) {
        if (i % 3 == 0 && i != lenb) printf(",%d", b[i]);
        else printf("%d", b[i]);
    }
    return 0;
}

