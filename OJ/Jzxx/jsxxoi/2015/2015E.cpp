/*2875: 【提高】买木头
时间限制 : 1 Sec内存限制 : 128 Mb提交 : 121解决 : 60
题目描述
有n个木材供应商（1≤n≤10000），每个供货商有长度相同一定数量的木头。长木头可以锯短，但短木头不能接长。有一个客人要求m根长度相同的木头。
要求计算出，此时供货商提供的木头满足客人要求的最长的长度是多少。
例如n=2,m=30，两个供货商的木头为
12,10     第1个供货商的木头长度为12，共有10根；
5,10      第2个供货商的木头长度为5，共有10根。
计算的结果为5，即长度为12的木头一根可锯出两根长度为5的木头，多余的无用，长度为5的木头不动，此事可得到30根长度为5的木头。
 
输入
整数n,m,l_1,s_1（1≤m≤1000000,1≤l_1≤10000,1≤s_1≤100）
其中l_1是第一个供货商木头的长，s_1是第一个供货商木头数量。其他供货商木头的长度和数量l_i和s_i（i≥2），由下面的公式给出：
l_i=((l_(i-1)×37011+10193)  mod 10000)+1
s_i=((s_(i-1)×73011+24793)  mod 100)+1
 
输出
一个整数，即满足要求的m根长度相同的木头的最大长度。
 
样例输入 [复制]
10 10000 8 20
样例输出 [复制]
201*/

//
// Created by Hz Yang on 2017/5/8.
//
#include <iostream>
using namespace std;

int main() {
    int n, m, l[1010], s[1010], max = 0, count = 0;
    cin >> n >> m >> l[1] >> s[1];
    for (int i = 2; i <= n; ++i) {
        l[i] = ((l[i - 1] * 37011 + 10193) % 10000) + 1;
        s[i] = ((s[i - 1] * 73011 + 24793) % 100) + 1;
        max = max > l[i] ? max : l[i];
    }
    while (max > 0) {
        count = 0;
        for (int i = 1; i <= n; ++i) {
            count += l[i] / max * s[i];
            if (count >= m) {
                cout << max << endl;
                return 0;
            }
        }
        max--;
    }
    cout << max << endl;
    return 0;
}
